<!--START_SECTION:medium-->
[Baca di Medium](https://medium.com/@dikaelsaputra/polimorfisme-dalam-pemrograman-java-39890c0a08ea?source=rss-272e0aace4a6------2)

<figure><img alt="" src="https://cdn-images-1.medium.com/max/750/0*wiVfPfcjZr6ZlMIq.png" /></figure><p>Polimorfisme adalah salah satu konsep penting dalam pemrograman berorientasi objek (OOP). Dalam Java, polimorfisme memungkinkan suatu objek untuk memiliki banyak bentuk. Secara umum, polimorfisme dibagi menjadi dua jenis:</p><ol><li><strong>Polimorfisme Compile-time (Static Polymorphism)</strong> — Polimorfisme ini dicapai melalui method overloading.</li><li><strong>Polimorfisme Runtime (Dynamic Polymorphism)</strong> — Polimorfisme ini dicapai melalui method overriding.</li></ol><h3>Polimorfisme Compile-time (Static Polymorphism)</h3><p>Contoh berikut menunjukkan penggunaan overloading pada metode jumlahkan() di kelas Kalkulator.</p><pre>public class Kalkulator { <br />  // Metode untuk menjumlahkan dua bilangan bulat <br />  public int jumlahkan(int a, int b) { <br />    return a + b; <br />  } <br /> // Metode untuk menjumlahkan dua bilangan desimal <br />  public double jumlahkan(double a, double b) { <br />    return a + b; <br />  } <br /> // Metode untuk menjumlahkan tiga bilangan bulat <br />  public int jumlahkan(int a, int b, int c) { <br />    return a + b + c; <br />  } <br />}</pre><pre>public class Main { <br />  public static void main(String[] args) { <br />    Kalkulator kalkulator = new Kalkulator(); <br />    int hasil1 = kalkulator.jumlahkan(5, 3); <br />    double hasil2 = kalkulator.jumlahkan(2.5, 3.7); <br />    int hasil3 = kalkulator.jumlahkan(1, 2, 3); <br />    System.out.println(hasil1); // Output: 8 <br />    System.out.println(hasil2); // Output: 6.2 <br />    System.out.println(hasil3); // Output: 6 <br />  } <br />}</pre><h4>Penjelasan Program:</h4><p>Dalam contoh di atas, metode jumlahkan() memiliki beberapa versi yang menerima parameter berbeda. Hal ini memungkinkan kita memanggil metode yang sama, tetapi dengan argumen yang berbeda.</p><h4><strong>Keuntungan menggunakan Overloading:</strong></h4><ul><li>Meningkatkan keterbacaan kode dengan mendefinisikan beberapa versi metode yang memiliki nama sama tetapi dengan parameter berbeda.</li><li>Menghindari penggunaan nama metode yang mirip untuk operasi serupa.</li></ul><h3>Polimorfisme Runtime (Dynamic Polymorphism)</h3><p>Dynamic Polymorphism dicapai melalui <strong>method overriding</strong>. Berikut adalah contoh di mana kelas Kucing dan Anjing mewarisi kelas induk Hewan dan masing-masing meng-override metode suara().</p><pre>class Hewan { <br />  public void suara() { <br />    System.out.println("Hewan bersuara"); <br />  } <br />}<br />class Kucing extends Hewan { <br />  @Override <br />  public void suara() { <br />    System.out.println("Meow"); <br />  } <br />}<br />class Anjing extends Hewan { <br />  @Override <br />  public void suara() { <br />    System.out.println("Woof"); <br />  } <br />}</pre><pre>public class Main { <br />  public static void main(String[] args) { <br />    Hewan hewan = new Kucing(); <br />    hewan.suara(); // Output: Meow <br />  } <br />}</pre><h4>Penjelasan Kode Program:</h4><ul><li>Pada kode di atas, objek hewan adalah referensi ke kelas Hewan, namun memegang objek dari kelas Kucing.</li><li>Ketika metode suara() dipanggil, Java secara otomatis memanggil metode yang ada di kelas Kucing, meskipun referensinya adalah kelas Hewan. Ini adalah contoh polimorfisme runtime.</li></ul><h4>Keuntungan Menggunakan Overriding:</h4><ul><li>Polimorfisme memungkinkan satu metode untuk bertindak berbeda pada objek yang berbeda, meskipun nama metode tetap sama.</li><li>Overriding berguna saat kita memiliki hirarki kelas yang besar, dan setiap kelas turunan memiliki implementasi spesifik dari metode yang sama.</li></ul><h3>Perbedaan Overloading dan Overriding</h3><p>Berikut adalah tabel perbedaan antara Overloading dan Overriding:</p><a href="https://medium.com/media/95d71fe67445759aa7466047fbd3fea8/href">https://medium.com/media/95d71fe67445759aa7466047fbd3fea8/href</a><h3>Persiapan</h3><p>Sebelum kita masuk ke latihan, pastikan Anda memiliki software yang dibutuhkan:</p><ul><li><strong>NetBeans atau IDE Lain</strong>: Sebagai lingkungan pengembangan Java, jika belum punya silahkan ikuti <a href="https://medium.com/@dikaelsaputra/cara-instal-netbeans-ide-di-windows-7e29e0815459">klik di sini</a>.</li><li><strong>Java Development Kit (JDK)</strong>: Pastikan JDK sudah terpasang, unduh <a href="https://www.oracle.com/java/technologies/downloads/#java17">JDK versi 17</a> atau <a href="https://www.oracle.com/java/technologies/downloads/#jdk23-windows">di atasnya</a>.</li></ul><p><strong>Langkah-langkah persiapan:</strong></p><ul><li>Buka NetBeans atau IDE yang sudah terpasang di komputer Anda.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*Sr5IVwfH6-cjMxKUvs9B2Q.png" /></figure><ul><li>Buat proyek baru dengan nama PraktikumPBO_6.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/815/1*8NIJ1QvdkptFuzpUbCDuUQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*DcFPJSsEYFBwuXjlXw1LdQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*nSksYJlEwzOu8E6ry7dXhg.png" /></figure><ul><li>Buat package baru dengan nama praktikum6.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*H8WK5uxi6cVPK0AyAqskoQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*3KfRl8gi4rgEuHfgdEnWrQ.png" /></figure><h3>Overloading dalam Java</h3><p>Overloading memungkinkan kita menggunakan nama metode yang sama dengan parameter yang berbeda. Buat kelas Hewan yang memiliki metode makan() yang di-overload.</p><p><strong>Langkah-langkah:</strong></p><ul><li>Buat kelas induk Hewan yang memiliki metode makan() dengan dua versi. Satu metode menerima parameter String makanandan satu lagi menerima parameter String makanan dan int jumlah.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*VpS69KKKBNfhgWtBFTNyRw.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*36C9X58NU2dPqQMIAHo-ow.png" /></figure><pre>public class Hewan {<br />    public void bersuara() {<br />        System.out.println("Hewan bersuara");<br />    }<br /><br />    public void makan(String makanan) {<br />        System.out.println("Hewan makan " + makanan);<br />    }<br /><br />    public void makan(String makanan, int jumlah) {<br />        System.out.println("Hewan makan " + jumlah + " porsi " + makanan);<br />    }<br />}</pre><p><strong>Buat objek dan panggil metode</strong>:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*r58eZi1pqZi7IZjD6m9IAA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*OFZnTWU809bXQzHyrPCwkQ.png" /></figure><pre>public class Main {<br />  public static void main(String[] args) {<br />    Hewan kucing = new Hewan();<br />    kucing.makan("ikan"); // Memanggil metode pertama<br />    kucing.makan("ikan", 2); // Memanggil metode kedua<br />  }<br />}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*gzCbmm9gSs9oiYABSZoE6g.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*AAxawuQ7zPZmL_WUb174uw.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*WkqMJd45_1JjGs2cHRY4wA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*O4NxL4S4v3SODBdThkmJgg.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*RkSK0pe71ILDUMU7B3ws2w.png" /></figure><p><strong><em>Perhatikan output pada program</em></strong><em>, apakah outputnya berbeda?</em></p><ul><li>Overloading adalah ketika ada beberapa metode dengan nama yang sama tetapi memiliki parameter yang berbeda (baik dari segi jumlah atau tipe datanya). Dalam contoh program yang diberikan, metode makan() di-<em>overload</em> untuk menerima jumlah parameter yang berbeda.</li></ul><p>Saat memanggil metode makan(), program akan memilih metode yang sesuai berdasarkan argumen yang diberikan. Contoh:</p><pre>kucing.makan("ikan");          // Memanggil metode makan(String)<br />kucing.makan("ikan", 2);       // Memanggil metode makan(String, int)</pre><p><strong>Output:</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*9CjijFKerFZun5qgP0FM4g.png" /></figure><p>Pada kasus overloading ini, <strong>output-nya memang berbeda</strong> karena metode yang dipanggil berbeda, tergantung pada parameter yang diberikan.</p><h3>Overriding dalam Java</h3><p>Overriding digunakan untuk memberikan perilaku yang berbeda pada kelas turunan. Buat dua kelas turunan dari Hewan yaitu Kucing dan Anjing yang meng-override metode bersuara() dari kelas induk.</p><p><strong>Langkah-langkah:</strong></p><ul><li>Buat kelas Kucing dan Anjing yang meng-override metode bersuara() dari kelas Hewan.</li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*2QafzhsgYVmnnPxTCZkwFw.png" /></figure><pre>public class Kucing extends Hewan {<br />  @Override<br />  public void bersuara() {<br />    System.out.println("Meow");<br />  }<br />}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*cl39ZRhle9ZkWS4dq51MFA.png" /></figure><pre>public class Anjing extends Hewan {<br />  @Override<br />  public void bersuara() {<br />    System.out.println("Woof");<br />  }<br />}</pre><p><strong>Gunakan polimorfisme runtime</strong>:</p><pre>public class Main {<br />  public static void main(String[] args) {<br />    Hewan hewan1 = new Kucing();<br />    hewan1.bersuara(); // Output: Meow<br />    Hewan hewan2 = new Anjing();<br />    hewan2.bersuara(); // Output: Woof<br />  }<br />}</pre><p>Dari program di atas, polimorfisme memungkinkan satu referensi (Hewan) untuk memegang berbagai jenis objek (Kucing dan Anjing) dan memanggil metode yang sesuai berdasarkan jenis objek.</p><p><strong><em>Perhatikan output pada program, </em></strong><em>apakah outputnya berbeda?</em></p><ul><li>Overriding adalah ketika metode dari kelas induk digantikan oleh metode dengan nama yang sama di kelas turunan.</li></ul><p>Saat memanggil metode bersuara() pada objek dari kelas turunan seperti Kucing atau Anjing, metode yang dipanggil adalah metode yang telah di-<em>override</em> di kelas turunan, bukan yang ada di kelas induk. Contoh:</p><pre>Hewan hewan1 = new Kucing();<br />hewan1.bersuara(); // Output: Meow<br />Hewan hewan2 = new Anjing();<br />hewan2.bersuara(); // Output: Woof</pre><p><strong>Output:</strong></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*mzodkjEBjtzDIcAW2LEU5w.png" /></figure><p>Pada kasus overriding, <strong>output-nya juga berbeda</strong>, karena setiap kelas turunan (Kucing dan Anjing) telah meng-override metode bersuara() dengan implementasi yang berbeda.</p><h3>Soal Latihan</h3><p>Untuk memahami lebih lanjut tentang konsep polimorfisme, cobalah mengerjakan soal di bawah ini:</p><p><strong>Soal</strong>:</p><ol><li>Buat kelas abstrak Produk dengan atribut nama dan harga.</li><li>Buat kelas turunan Buku, Elektronik, dan Pakaian yang mewarisi kelas Produk.</li><li>Override metode hitungDiskon() pada setiap kelas turunan untuk menghitung diskon yang berbeda-beda.</li><li>Buat kelas KeranjangBelanja yang menyimpan daftar produk (List<Produk>) dan memiliki metode untuk menghitung total harga setelah diskon.</li></ol><h4>Petunjuk:</h4><ul><li>Buat metode hitungDiskon() yang berbeda pada setiap kelas turunan.</li><li>Implementasikan metode untuk menambahkan produk ke KeranjangBelanja.</li><li>Buatlah sebuah metode untuk menampilkan total harga semua produk setelah diskon.</li></ul><h4>Membuat Kelas Abstrak Produk</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*ueLoNa0FgUdUeuPOxVMoNg.png" /></figure><p>Kelas abstrak Produk berfungsi sebagai superclass yang akan diwariskan ke kelas-kelas turunan lainnya.</p><pre>public abstract class Produk {<br />    protected String nama;<br />    protected double harga;<br />    public Produk(String nama, double harga) {<br />        this.nama = nama;<br />        this.harga = harga;<br />    }<br />    // Metode abstrak untuk menghitung diskon<br />    public abstract double hitungDiskon();<br />    public String getNama() {<br />        return nama;<br />    }<br />    public double getHarga() {<br />        return harga;<br />    }<br />}</pre><h4>Membuat Kelas Turunan Buku, Elektronik, dan Pakaian</h4><p>Setiap kelas turunan mengimplementasikan metode hitungDiskon() dengan cara yang berbeda.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*EdBKoJpw3qELssRrPamEMw.png" /></figure><pre>public class Buku extends Produk {<br />    public Buku(String nama, double harga) {<br />        super(nama, harga);<br />    }<br />    @Override<br />    public double hitungDiskon() {<br />        return harga * 0.9; // Diskon 10% untuk buku<br />    }<br />}</pre><pre>public class Elektronik extends Produk {<br />    public Elektronik(String nama, double harga) {<br />        super(nama, harga);<br />    }<br />    @Override<br />    public double hitungDiskon() {<br />        return harga * 0.85; // Diskon 15% untuk elektronik<br />    }<br />}</pre><pre>public class Pakaian extends Produk {<br />    public Pakaian(String nama, double harga) {<br />        super(nama, harga);<br />    }<br />    @Override<br />    public double hitungDiskon() {<br />        return harga * 0.8; // Diskon 20% untuk pakaian<br />    }<br />}</pre><h4>Membuat Kelas KeranjangBelanja</h4><p>Kelas ini akan menyimpan daftar produk dan menghitung total harga setelah diskon.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*GK3A6w7_-LDzAllREuKNcQ.png" /></figure><pre>import java.util.ArrayList;<br />import java.util.List;<br />class KeranjangBelanja {<br />    private List<Produk> daftarProduk;<br />    public KeranjangBelanja() {<br />        daftarProduk = new ArrayList<>();<br />    }<br />    // Menambahkan produk ke dalam keranjang<br />    public void tambahProduk(Produk produk) {<br />        daftarProduk.add(produk);<br />    }<br />    // Menghitung total harga setelah diskon<br />    public double hitungTotalHarga() {<br />        double total = 0;<br />        for (Produk produk : daftarProduk) {<br />            total += produk.hitungDiskon();<br />        }<br />        return total;<br />    }<br />    // Menampilkan detail produk di dalam keranjang<br />    public void tampilkanProduk() {<br />        for (Produk produk : daftarProduk) {<br />            System.out.println("Produk: " + produk.getNama() + ", Harga: " + produk.getHarga() + ", Harga setelah diskon: " + produk.hitungDiskon());<br />        }<br />    }<br />}</pre><h4>Menguji Program</h4><p>Buat main class untuk menguji seluruh implementasi di atas.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*67AC-0GkdSGcEwEVUYuXrQ.png" /></figure><pre>public class Main {<br />    public static void main(String[] args) {<br />        // Membuat beberapa objek produk<br />        Produk buku = new Buku("Buku Java", 100000);<br />        Produk elektronik = new Elektronik("Laptop", 5000000);<br />        Produk pakaian = new Pakaian("Jaket", 300000);<br />        // Membuat keranjang belanja<br />        KeranjangBelanja keranjang = new KeranjangBelanja();<br />        // Menambahkan produk ke dalam keranjang<br />        keranjang.tambahProduk(buku);<br />        keranjang.tambahProduk(elektronik);<br />        keranjang.tambahProduk(pakaian);<br />        // Menampilkan produk yang ada di keranjang<br />        System.out.println("Detail Produk dalam Keranjang:");<br />        keranjang.tampilkanProduk();<br />        // Menghitung dan menampilkan total harga setelah diskon<br />        double totalHarga = keranjang.hitungTotalHarga();<br />        System.out.println("\nTotal Harga setelah diskon: " + totalHarga);<br />    }<br />}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*c6fbf7UVEOUYol6MkZmknQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*TGAkKP53N6Y8t22sHn5ysA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*IuLqjtyD8jJfTstGzQ-3Qg.png" /></figure><h3>Penjelasan:</h3><p><strong>Kelas </strong><strong>Produk:</strong></p><ul><li>Kelas ini merupakan kelas abstrak yang mendefinisikan dua atribut, nama dan harga, serta metode abstrak hitungDiskon() yang akan diimplementasikan di kelas-kelas turunannya.</li></ul><p><strong>Kelas Turunan </strong><strong>Buku, </strong><strong>Elektronik, dan </strong><strong>Pakaian:</strong></p><ul><li>Setiap kelas ini meng-override metode hitungDiskon(). Misalnya, untuk Buku, diskon sebesar 10%, untuk Elektronik sebesar 15%, dan untuk Pakaian sebesar 20%.</li></ul><p><strong>Kelas </strong><strong>KeranjangBelanja:</strong></p><ul><li>Kelas ini memiliki list produk (List<Produk>), serta metode tambahProduk() untuk menambahkan produk ke dalam list, hitungTotalHarga() untuk menghitung total harga setelah diskon, dan tampilkanProduk() untuk menampilkan detail produk dalam keranjang.</li></ul><p><strong>Main Class (</strong><strong>Main):</strong></p><p>Di dalam main class, beberapa produk ditambahkan ke dalam KeranjangBelanja. Kemudian, total harga setelah diskon dihitung dan ditampilkan bersama dengan detail setiap produk.</p><h4>Output Program:</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/827/1*PW3wdGWp4iTBPo5A6Vnr8Q.png" /></figure><h3>Keuntungan Menggunakan Polimorfisme</h3><ul><li><strong>Fleksibilitas:</strong> Memungkinkan satu metode untuk menangani berbagai objek.</li><li><strong>Pemeliharaan Kode:</strong> Dengan overriding, perilaku metode dapat diubah pada subclass tanpa harus memodifikasi kode di superclass.</li><li><strong>Kode yang Lebih Bersih:</strong> Overloading memberikan cara untuk menggunakan satu nama metode untuk beberapa tindakan, sehingga membuat kode lebih bersih dan mudah dibaca.</li></ul><h3>Kesimpulan</h3><p>Polimorfisme dalam Java memberikan fleksibilitas dan efisiensi dengan memungkinkan metode untuk berperilaku berbeda tergantung pada objek yang memanggilnya. Overloading memberikan kemampuan untuk menggunakan satu nama metode untuk berbagai jenis parameter, sedangkan overriding memungkinkan metode pada kelas turunan untuk mengganti perilaku metode pada kelas induk. Polimorfisme sangat berguna untuk menjaga kode tetap bersih dan mudah diperluas, terutama ketika bekerja dengan hirarki kelas yang kompleks.</p><h3>Referensi</h3><p><a href="https://entri.app/blog/understanding-polymorphism-in-java/">Understanding Polymorphism In Java - Entri Blog</a></p><img alt="" height="1" src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=39890c0a08ea" width="1" />
<!--END_SECTION:medium-->